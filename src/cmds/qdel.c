/*
 * Copyright (C) 1994-2020 Altair Engineering, Inc.
 * For more information, contact Altair at www.altair.com.
 *
 * This file is part of both the OpenPBS software ("OpenPBS")
 * and the PBS Professional ("PBS Pro") software.
 *
 * Open Source License Information:
 *
 * OpenPBS is free software. You can redistribute it and/or modify it under
 * the terms of the GNU Affero General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * OpenPBS is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Commercial License Information:
 *
 * PBS Pro is commercially licensed software that shares a common core with
 * the OpenPBS software.  For a copy of the commercial license terms and
 * conditions, go to: (http://www.pbspro.com/agreement.html) or contact the
 * Altair Legal Department.
 *
 * Altair's dual-license business model allows companies, individuals, and
 * organizations to create proprietary derivative works of OpenPBS and
 * distribute them - whether embedded or bundled with other software -
 * under a commercial license agreement.
 *
 * Use of Altair's trademarks, including but not limited to "PBS™",
 * "OpenPBS®", "PBS Professional®", and "PBS Pro™" and Altair's logos is
 * subject to Altair's trademark licensing policies.
 */

/**
 * @file	qdel.c
 * @brief
 * 	qdel - (PBS) delete batch job
 *
 * @author  Terry Heidelberg
 * 			Livermore Computing
 *
 * @author  Bruce Kelly
 * 			National Energy Research Supercomputer Center
 *
 * @author  Lawrence Livermore National Laboratory
 * 			University of California
 */

#include <unistd.h>
#include "cmds.h"
#include "pbs_ifl.h"
#include <pbs_config.h>   /* the master config generated by configure */
#include <pbs_version.h>

#define NO_OF_JOBIDS 1000 /* Using this macro to allocate array of pointers */

typedef struct svr_jobid_list svr_jobid_list_t;
struct svr_jobid_list{
	int max_sz;
	int total_jobs;
	char *server_name;
	char **jobids;
	svr_jobid_list_t *next;
};

/**
 * @brief
 *	Append a given jobid to the given svr_jobid_list struct.
 *
 * @param[in] svr - Server name
 * @param[in] jobid - Job id 
 * 
 * @return void
 */
void
append_jobid(svr_jobid_list_t *svr, char *jobid)
{
	
	if ((svr == NULL) || (jobid == NULL))
		return;
	
	if (svr->max_sz == 0) {
		svr->jobids = malloc((NO_OF_JOBIDS + 1) * sizeof(char *));
		if (svr->jobids == NULL) 
			goto error;
		svr->max_sz = NO_OF_JOBIDS;
	} else if (svr->total_jobs == svr->max_sz) {
		svr->max_sz *= 2;
		svr->jobids = realloc(svr->jobids, (svr->max_sz + 1) * sizeof(char *));
		if (svr->jobids == NULL) 
			goto error;
	}
	
	svr->jobids[svr->total_jobs++] = jobid;
	svr->jobids[svr->total_jobs] = NULL;
	return;

error:
	fprintf(stderr, "qdel: unable to allocate memory.\n");
	exit(2);	
}

/**
 * @brief
 *	Identify the respective svr_jobid_list struct 
 *  and calls the append_jobid function to append the jobid.
 *
 * @param[in] job_id - Job id 
 * @param[in] server - server name
 * @param[in,out] svr_jobid_list_hd - head of the svr_jobib_list list
 * 
 * @return int
 * @retval	0	- success
 * @retval	1	- failure
 *
 */
int
add_jid_to_list(char *job_id, char *server, svr_jobid_list_t** svr_jobid_list_hd)
{
	svr_jobid_list_t *iter_list = NULL;
	svr_jobid_list_t *prev = NULL;
	svr_jobid_list_t *new_node = NULL;

	if ((job_id == NULL) || (server == NULL) || (svr_jobid_list_hd == NULL))
		return 1;

	for (iter_list = *svr_jobid_list_hd; iter_list != NULL; prev = iter_list, iter_list = iter_list->next) {
		if (strcmp(server, iter_list->server_name) == 0) {
			append_jobid(iter_list, job_id);
			break;
		}
	}

	if (iter_list == NULL) {
		new_node = calloc(1, sizeof(svr_jobid_list_t));
		if (new_node == NULL)
			goto error;
		new_node->server_name = strdup(server);
		if (new_node->server_name == NULL)
			goto error;
		append_jobid(new_node, job_id);
		if (prev != NULL)
			prev->next = new_node;
		else
			*svr_jobid_list_hd = new_node;
	}

	return 0;
	
error:
	fprintf(stderr, "qdel: unable to allocate memory.\n");
	exit(2);
}


int
main(argc, argv, envp) /* qdel */
int argc;
char **argv;
char **envp;
{
	int c;
	int errflg=0;
	int any_failed=0;
	char *pc;

	int forcedel = FALSE;
	int deletehist = FALSE;
	int mails_suppressed = FALSE;

	char job_id_out[PBS_MAXCLTJOBID];
	char server_out[MAXSERVERNAME];
	char rmt_server[MAXSERVERNAME];

	char *keystr, *valuestr;
	int dfltmail = 0;
	int dfltmailflg = FALSE;
	int mails;				/* number of emails we can send */
	int num_deleted = 0;
	int num_failed = 0;
	struct attrl *attr;
	struct batch_status *ss = NULL;
	char *errmsg;
	svr_jobid_list_t *svr_jobid_list_hd = NULL;
	svr_jobid_list_t *svr_itr = NULL;
	svr_jobid_list_t *prev = NULL;
	int connect;
	struct batch_deljob_status *p_delstatus;
	char *errtxt = NULL;
	int i;
	int numofjobs;

#define MAX_TIME_DELAY_LEN 32
	/* -W no longer supports a time delay */
	/* max length is "nomailforcedeletehist" plus terminating '\0' */
	char warg[MAX_TIME_DELAY_LEN+1];
	char warg1[MAX_TIME_DELAY_LEN+7];

#define GETOPT_ARGS "W:x"
#define NUM_JOBS_IN_A_BATCH 10000

	/*test for real deal or just version and exit*/

	PRINT_VERSION_AND_EXIT(argc, argv);

	if (initsocketlib())
		return 1;

	warg[0]='\0';
	strcpy(warg1, NOMAIL);
	while ((c = getopt(argc, argv, GETOPT_ARGS)) != EOF) {
		switch (c) {
			case 'W':
				pc = optarg;
				if (strlen(pc) == 0) {
					fprintf(stderr, "qdel: illegal -W value\n");
					errflg++;
					break;
				}
				if (strcmp(pc, FORCE) == 0) {
					forcedel = TRUE;
					break;
				}
				if (parse_equal_string(optarg, &keystr, &valuestr)) {
					if (strcmp(keystr, SUPPRESS_EMAIL) == 0) {
						dfltmail = atol(valuestr);
						dfltmailflg = TRUE;
						break;
					}
				}

				while (*pc != '\0') {
					if (! isdigit(*pc)) {
						fprintf(stderr, "qdel: illegal -W value\n");
						errflg++;
						break;
					}
					pc++;
				}
				break;
			case  'x' :
				deletehist = TRUE;
				break;
			default :
				errflg++;
		}
	}

	if (errflg || optind >= argc) {
		static char usage[] =
			"usage:\n"
		"\tqdel [-W force|suppress_email=X] [-x] job_identifier...\n"
		"\tqdel --version\n";
		fprintf(stderr, "%s", usage);
		exit(2);
	}

	if (forcedel && deletehist)
		snprintf(warg, sizeof(warg), "%s%s", FORCE, DELETEHISTORY);
	else if (forcedel)
		strcpy(warg, FORCE);
	else if (deletehist)
		strcpy(warg, DELETEHISTORY);

	/*perform needed security library initializations (including none)*/

	if (CS_client_init() != CS_SUCCESS) {
		fprintf(stderr, "qdel: unable to initialize security library.\n");
		exit(1);
	}
			
	for (; optind < argc; optind++) {
		if (get_server(argv[optind], job_id_out, server_out)) {
			fprintf(stderr, "qdel: illegally formed job identifier: %s\n", argv[optind]);
			any_failed = 1;
			continue;
		}
		if (server_out[0] == '\0')
			strcpy(server_out, pbs_default());
		add_jid_to_list(argv[optind], server_out, &svr_jobid_list_hd);
	}

	for (svr_itr = svr_jobid_list_hd; svr_itr != NULL; prev = svr_itr, svr_itr = svr_itr->next) {
		if (prev != NULL) {
			free(prev->jobids);
			free(prev);
		}
		
		connect = cnt2server(svr_itr->server_name);
		if (connect <= 0) {
			fprintf(stderr, "qdel: cannot connect to server %s (errno=%d)\n",
				pbs_server, pbs_errno);
			any_failed = pbs_errno;
			continue;
		}

		/* retrieve default: suppress_email from server: default_qdel_arguments */
		if (dfltmailflg == FALSE) {
			ss = pbs_statserver(connect, NULL, NULL);
			if (ss == NULL && pbs_errno != PBSE_NONE) {
				any_failed = pbs_errno;
				if ((errmsg = pbs_geterrmsg(connect)) != NULL)
					fprintf(stderr, "qdel: %s\n", errmsg);
				else
					fprintf(stderr, "qdel: Error %d\n", pbs_errno);
				break;
			}

			while (ss != NULL && dfltmailflg != TRUE) {
				attr = ss->attribs;
				while (attr != NULL) {
					if (strcmp(attr->name, ATTR_dfltqdelargs) == 0) {
						if (attr->value != NULL && dfltmailflg != TRUE) {
							if (parse_equal_string(attr->value, &keystr, &valuestr)) {
								if (strcmp(keystr, "-Wsuppress_email") == 0) {
									dfltmail = atol(valuestr);
									dfltmailflg = TRUE;
								}
								else {
									fprintf(stderr,
										"qdel: unsupported %s \'%s\'\n",
										attr->name, attr->value);
								}
							}
						}
					}
					attr = attr->next;
				}
				ss = ss->next;
			}
		}

		/* when jobs to be deleted over 1000, mail function is disabled
		 * by sending the flag below to server via its extend field:
		 *   "" -- delete a job with a mail
		 *   "nomail" -- delete a job without sending a mail
		 *   "force" -- force job to be deleted with a mail
		 *   "nomailforce" -- force job to be deleted without sending a mail
		 *   "nomaildeletehist" -- delete history of a job without sending mail
		 *   "nomailforcedeletehist" -- force delete history of a job without sending mail.
		 */
		mails = dfltmail ? dfltmail : 1000;
		numofjobs = (mails <= svr_itr->total_jobs) ? mails : svr_itr->total_jobs;
		
		for (i = 0; i < svr_itr->total_jobs; i = i + numofjobs) {
			if (mails_suppressed)
				numofjobs = NUM_JOBS_IN_A_BATCH;
				
			numofjobs = ((i + numofjobs) <= svr_itr->total_jobs) ? numofjobs : (svr_itr->total_jobs - i);	
			p_delstatus = pbs_deljoblist(connect, &(svr_itr->jobids[i]), numofjobs, warg);
			num_failed = 0;
			for (; p_delstatus != NULL; p_delstatus = p_delstatus->next) {
				if (p_delstatus->code != PBSE_HISTJOBDELETED)
					num_failed++;
				if (p_delstatus->code == PBSE_UNKJOBID) {
					if (locate_job(p_delstatus->name, server_out, rmt_server))
						add_jid_to_list(p_delstatus->name, rmt_server, &svr_itr);
					continue;
				}
				errtxt = pbse_to_txt(p_delstatus->code);
				if ((errtxt != NULL) && (p_delstatus->code != PBSE_HISTJOBDELETED)) {
					fprintf(stderr, "%s: %s %s\n", "qdel", errtxt, p_delstatus->name);
					any_failed = p_delstatus->code;
				}
			}
			num_deleted += numofjobs - num_failed;
			
			if (num_deleted >= mails && !mails_suppressed) {
				mails_suppressed = TRUE;
				/* current warg1 "nomail" should be at start */
				strcat(warg1, warg);
				pbs_strncpy(warg, warg1, sizeof(warg));
			}
		}

		pbs_disconnect(connect);
	}

	/*cleanup security library initializations before exiting*/
	CS_close_app();

	exit(any_failed);
}
